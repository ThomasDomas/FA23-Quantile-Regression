# Analysis

In this analysis we aim to show that QR can achieve similar, if not better, performance to OLS across various metrics. In order to make the comparisons fair, we will compare the 50th quantile QR, which corresponds to the median, to OLS regression as both the median and mean are measures of centrality. The power of QR is that it is able to produce similar results to OLS regression without having to meet the strict assumptions of OLS such as the assumption of normality. In fact, in this data set neither the response variable or predictor variables meet the assumptions of OLS, and therefore regardless of the performance of OLS it is invalid.

```{r, echo=FALSE, include=FALSE}
# installing/loading the package:
# if(!require(installr)) {
#   install.packages("installr"); 
#   require(installr)
# } #load / install+load installr
# # using the package:
# updateR()

# install.packages('rmarkdown')
# install.packages("quantreg")
library("quantreg")
#library(sjPlot)
library(haven)
library(gridExtra)
library(tidyverse)
library(Metrics)
#library(equatiomatic)
#library(fastDummies)
#library(pscl)

#library(gsheet)
#library(brant)
#library(MASS)
#library(lmtest)
#library(reshape2)

#library(nnet)
#library(AER)
#library(boot)

#library(asaur)

```

## Visualization

```{r, 'Getting Data housing'}
df <- read.csv("TrainData.csv") |>
  na.omit() |>
  distinct()

```

### Visualizing data

There are many different kinds of predictor variables in this data set. For instance, there are continuous variables like GrLivArea, discrete/coutning variables likr YearBuilt, and categorical variables like HouseStyle. In all cases we cases we can see that the data is not normally distributed, including in the response variable, SalePrice. Thus, the assumptions of OLS are not met so it cannot be used to make predictions on the data. However, for the purposes of comparing the performance of OLS to QR. We will show that QR is able to give similar results for this data set to OLS, and because it does not require the same assumptions as OLS, one can actually use QR in practice for this kind of data, which is more common than normally distributed data in many important fields, like finance and epidemiology. 

```{r 'Visualizing data'}
suppressWarnings({

p1 <- df |> ggplot(aes(x = GrLivArea)) +
  geom_histogram(binwidth = 100) +
  theme_bw() +
  ylab(NULL) +
  xlab("Above Ground Area (sq. ft.)")

p2 <- df |> ggplot(aes(x = YearBuilt)) +
  geom_histogram(binwidth = 5) +
  theme_bw() +
  ylab(NULL) +
  xlab("Year Built")

p3 <- df |> ggplot(aes(x = HouseStyle)) +
  geom_histogram(stat="count") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylab(NULL) +
  xlab("House Style")

p4 <- df |> ggplot(aes(x = SalePrice)) +
  geom_histogram(binwidth = 10000) +
  theme_bw() +
  ylab(NULL) +
  xlab("Sale Price ($)")

grid.arrange(p1, p2, p3, p4, nrow = 2)
                 
})
```

### Visualizing quantile regression vs OLS

```{r, 'Visualizing housing'}

df |> ggplot(aes(y = SalePrice, x = LotArea)) +
  geom_point(size = 0.9) +
  geom_smooth(method = lm, se = F, color = "black") +
  geom_text(aes(y = 400000, x = 150000, label = "OLS"), color="black") + 
  geom_quantile(quantiles=0.5, color="red") + 
  geom_text(aes(y = 470000, x = 90000, label = "50th quantile"), color="red") + 
  ylab("Sale price ($)") +
  xlab("Lot area (Square feet)") +
  theme_bw()

# df |> ggplot(aes(y = SalePrice, x = GrLivArea)) +
#   geom_boxplot()

df |> ggplot(aes(y = SalePrice, x = GrLivArea)) +
  geom_point(size = 0.9) +
  stat_smooth(method = lm, color = "black") +
  geom_text(aes(x = 4150, y = 500000, label = "OLS"), color="black") + 
  geom_quantile(quantiles=0.25, color="red") + 
  geom_text(aes(x = 4000, y = 270000, label = "25th quantile"), color="red") + 
  geom_quantile(quantiles=0.5, color="blue") + 
  geom_text(aes(x = 4150, y = 400000, label = "50th"), color="blue") + 
  geom_quantile(quantiles=0.75, color="green") + 
  geom_text(aes(x = 4000, y = 600000, label = "75th quantile"), color="green") + 
  xlab("Sale price ($)") +
  ylab("Above ground area (Square feet)") +
  theme_bw()
```

## Model creation

### QR model

```{r 'QR model creation'}
qr50 = rq(data=df, SalePrice ~ GrLivArea + LotArea + TotRmsAbvGrd + as.factor(LotShape) + as.factor(Foundation), tau=0.5)
qr50_summary = summary(qr50)
qr50_summary
```

### OLS model

```{r 'OLS model creation'}
ols = lm(data=df, SalePrice ~ GrLivArea + LotArea + TotRmsAbvGrd + as.factor(LotShape) + as.factor(Foundation))
ols_summary = summary(ols)
ols_summary
```

## Model evaluation

### Mean absolute error
```{r 'Mean absolute error'}
olsMae = mae(predict(ols), df$SalePrice)
olsMae
Qr50Mae = mae(predict(qr50), df$SalePrice)
Qr50Mae
```

OLS MAE value: `r format(round(olsMae, digits=2), scientific=F)`.

And QR 50th MAE value: `r format(round(Qr50Mae, digits=2), scientific=F)`.

QR for 50th quantile has a lower MAE therefore it is has more accurate predictions.

### Root mean squared error
```{r 'Root mean squared error'}
olsRmse = rmse(predict(ols), df$SalePrice)
olsRmse
Qr50Rmse = rmse(predict(qr50), df$SalePrice)
Qr50Rmse
```

OLS RMSE value: `r format(round(olsRmse, digits=2), scientific=F)`.

And QR 50th RMSE value: `r format(round(Qr50Rmse, digits=2), scientific=F)`.

Since OLS algorithm's goal is to minimize RMSE, as expected it has a better (lower) value. But QR has a very similar value which shows how well QR model can keep up even if it is not focusing on optimizing RMSE.

### Variance of error
```{r 'Variance of error'}
ols_summary$df[2]
qr50_summary$rdf
```

The variance of error for OLS: `r format(ols_summary$df[2], scientific=F)`.

The variance of error for QR 50th: `r format(qr50_summary$rdf, scientific=F)`.

Both have the same variance of error.

### Min/max error
```{r 'Min/Max Error'}
# Min OLS error
format(round(min(ols_summary$residuals), digits=0), scientific=F)
# Absolute min OLS error
format(round(min(abs(ols_summary$residuals)), digits=0), scientific=F)
# Max OLS error
format(round(max(ols_summary$residuals), digits=0), scientific=F)
# Absolute max OLS error
format(round(max(abs(ols_summary$residuals)), digits=0), scientific=F)
# Min QR 50th error
format(round(min(qr50_summary$residuals), digits=0), scientific=F)
# Absolute min QR 50th error
format(round(min(abs(qr50_summary$residuals)), digits=0), scientific=F)
# Max QR 50th error
format(round(max(qr50_summary$residuals), digits=0), scientific=F)
# Absolute max QR 50th error
format(round(max(abs(qr50_summary$residuals)), digits=0), scientific=F)
```

#### OLS
Min OLS error: `r format(round(min(ols_summary$residuals), digits=0), scientific=F)`.

Absolute min OLS error: `r format(round(min(abs(ols_summary$residuals)), digits=0), scientific=F)`.

Max OLS error: `r format(round(max(ols_summary$residuals), digits=0), scientific=F)`.

Absolute max OLS error: `r format(round(max(abs(ols_summary$residuals)), digits=0), scientific=F)`.

#### QR
Min QR 50th error: `r format(round(min(qr50_summary$residuals), digits=0), scientific=F)`.

Absolute min QR 50th error: `r format(round(min(abs(qr50_summary$residuals)), digits=0), scientific=F)`.

Max QR 50th error: `r format(round(max(qr50_summary$residuals), digits=0), scientific=F)`.

Absolute max QR 50th error: `r format(round(max(abs(qr50_summary$residuals)), digits=0), scientific=F)`.
